[{"title":"Linux MySQL 5.7二进制 小版本快速升级","date":"2020-09-28T03:08:00.000Z","path":"2020/09/28/mysql/Linux MySQL 5.7二进制 小版本快速升级/","text":"注意，文中的目录路径请根据实际情况修改。 配置 mysql 慢速关闭 1mysql -u root -p --execute=\"SET GLOBAL innodb_fast_shutdown=0\" 关闭 mysql 服务 1mysqladmin -u root -p shutdown 备份数据文件 1mkdir /work/data_bak &amp;&amp; cp -r /work/data/* \"$_\" 备份原 mysql 应用文件 1mv /work/&#123;mysql,mysql_bak&#125; 使用新版 mysql 替换原 mysql 应用文件 1tar -xzvf mysql-5.7.31-linux-glibc2.12-x86_64.tar.gz 1mv /work/&#123;mysql-5.7.31-linux-glibc2.12-x86_64,mysql&#125; 修改文件所有者 1chown -R mysql:mysql /work/mysql 启动 mysql 服务 1mysqld_safe --user=mysql 启动完成后可使用 mysql -V 获取连接数据库 执行 select @@version 查看当前数据库版本 运行mysql_upgrade 1mysql_upgrade -u root -p 重启 mysql 服务 1mysqladmin -u root -p shutdown 1mysqld_safe --user=mysql 除了上述的方法，还可以通过逻辑升级的方式对mysql进行升级。逻辑升级就是导出数据，然后升级，最后再导入数据。安全性高，主要针对数据量不大的数据库，常用的工具：mysqldump和Xtrabackup。 扩展：innodb_fast_shutdown有3个取值： 设置为1：关闭MySQL的时候不会做清除脏页和插入缓冲区的合并操作，也不会将脏页刷新到磁盘 设置为0：会做清除脏页和插入缓冲区的合并操作，也会将脏页全部刷新到磁盘上面去，但是这个时候关闭的速度也是最慢的 设置为2：不会做清除脏页和插入缓冲区的合并操作，也不会将脏页刷新到磁盘，但是会刷新到redo log里面，再下次启动mysql的时候恢复"},{"title":"This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary log","date":"2020-09-26T09:10:00.000Z","path":"2020/09/26/mysql/This-function-has-none-of-DETERMINISTIC-NO-SQL-or-READS-SQL-DATA-in-its-declaration-and-binary-log/","text":"出错信息 This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you might want to use the less safe log_bin_trust_function_creators variable) 出错原因 开启了bin-log但是创建函数/存储过程时未指定类型 解决方法 1. 指定函数类型 在创建函数时在声明后面指定类型，如： 1234CREATE DEFINER=`root`@`%` FUNCTION `functionName`(`var1` varchar(2000)) RETURNS varchar(2000) CHARSET utf8mb4 READS SQL DATABEGIN ...END; 可选类型： DETERMINISTIC 不确定的 NO SQL 没有SQl语句，当然也不会修改数据 READS SQL DATA 只是读取数据，当然也不会修改数据 MODIFIES SQL DATA 要修改数据 CONTAINS SQL 包含了SQL语句 2. 临时修改配置（数据库重启失效） 连接数据库执行以下语句临时修改配置： 1set global log_bin_trust_function_creators=TRUE; 3. 修改数据库配置文件 在 [mysqld] 加入以下内容并重启数据库： 1log_bin_trust_function_creators=1 参考文章： https://blog.csdn.net/topasstem8/article/details/8216740 https://www.jb51.net/article/97037.htm"},{"title":"@Autowire和@Resource注解的区别","date":"2020-08-04T07:18:53.000Z","path":"2020/08/04/Java/Spring/@Autowire和@Resource注解的区别/","text":"@Autowire spring提供 属性：required 作用范围：字段、setter方法、构造器上 默认按类型（by-type）装配且对象不可为空（可设置 required=false 允许对象为空） 结合 @Qualifier(“beanName”) 可实现按名称装配 @Resource jdk提供 属性：name、type 作用范围：字段、setter方法 默认按名称(by-name)装配，名称可以通过name属性指定 未指定name的情况下： 当注解在字段上时，默认取name=字段名称装配 当注解在setter方法上时，默认取name=属性名称装配 若按照名称未匹配，则自动按类型匹配 装配顺序 同时指定name和type属性：则找到唯一匹配的bean装配，未找到则抛异常 指定name属性：按照名称(by-name)装配，未找到则抛异常 指定type属性：按照类型(by-type)装配，未找到或者找到多个则抛异常 未指定name属性又未指定type属性：先按照名称(by-name)装配，如果未找到，则按照类型(by-type)装配"}]